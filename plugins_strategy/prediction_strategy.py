"""
Prediction-Based Strategy Plugin for LTS

This strategy plugin uses the prediction provider to make trading decisions
based on predicted price movements for both short-term and long-term horizons.
"""

import logging
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass

from app.plugin_base import PluginBase
from app.prediction_client import PredictionProviderClient


@dataclass
class TradingSignal:
    """Represents a trading signal generated by the strategy."""
    action: str  # 'buy', 'sell', 'hold'
    confidence: float  # 0.0 to 1.0
    quantity: float
    reasoning: str
    timestamp: datetime
    short_term_predictions: List[float]
    long_term_predictions: List[float]
    uncertainties: Dict[str, List[float]]


class PredictionBasedStrategy(PluginBase):
    """
    Strategy plugin that uses prediction provider for trading decisions.
    
    This strategy combines short-term (1-6h) and long-term (1-6d) predictions
    to make informed trading decisions with confidence levels.
    """
    
    # Plugin-specific parameters
    plugin_params = {
        "short_term_weight": 0.6,
        "long_term_weight": 0.4,
        "confidence_threshold": 0.7,
        "uncertainty_threshold": 0.05,
        "position_size_base": 0.02,
        "trend_alignment_required": True
    }
    
    # Plugin-specific debug variables
    plugin_debug_vars = [
        "short_term_weight", "long_term_weight", "confidence_threshold",
        "uncertainty_threshold", "position_size_base", "trend_alignment_required"
    ]
    
    def __init__(self, config: Dict[str, Any] = None):
        super().__init__(config)
        self.name = "Prediction-Based Strategy"
        self.version = "1.0.0"
        self.description = "Strategy using prediction provider for ML-based trading decisions"
        
        # Plugin configuration
        self.prediction_client = None
        self.logger = logging.getLogger(__name__)
        
        # Strategy parameters (use plugin params)
        self.short_term_weight = self.params.get("short_term_weight", 0.6)
        self.long_term_weight = self.params.get("long_term_weight", 0.4)
        self.confidence_threshold = self.params.get("confidence_threshold", 0.7)
        self.uncertainty_threshold = self.params.get("uncertainty_threshold", 0.05)
        self.position_size_base = self.params.get("position_size_base", 0.02)
        self.trend_alignment_required = self.params.get("trend_alignment_required", True)
        
        # Initialize prediction client if config provided
        if config:
            self.prediction_client = PredictionProviderClient(config)
        
        self.logger.info(f"Initialized {self.name} v{self.version}")
    
    def set_prediction_client_config(self, config: Dict[str, Any]):
        """Set the prediction client configuration separately."""
        self.prediction_client = PredictionProviderClient(config)
    
    async def generate_signal(self, symbol: str, current_price: float, 
                            historical_data: List[Dict], portfolio_context: Dict) -> TradingSignal:
        """
        Generate a trading signal based on predictions.
        
        Args:
            symbol: Trading symbol (e.g., 'EURUSD')
            current_price: Current price of the asset
            historical_data: Recent historical price data
            portfolio_context: Current portfolio information
            
        Returns:
            TradingSignal with action, confidence, and reasoning
        """
        try:
            # Get current datetime for prediction
            current_time = datetime.now()
            datetime_str = current_time.isoformat()
            
            # Get predictions from prediction provider
            predictions = await self.prediction_client.get_predictions(
                symbol=symbol,
                datetime_str=datetime_str,
                prediction_types=['short_term', 'long_term']
            )
            
            if predictions['status'] != 'success':
                self.logger.warning(f"Prediction request failed for {symbol}: {predictions}")
                return self._create_hold_signal(current_time, "Prediction request failed")
            
            # Extract predictions and uncertainties
            short_term_preds = predictions['predictions'].get('short_term', [])
            long_term_preds = predictions['predictions'].get('long_term', [])
            uncertainties = predictions['uncertainties']
            
            if not short_term_preds or not long_term_preds:
                return self._create_hold_signal(current_time, "Insufficient prediction data")
            
            # Analyze predictions and generate signal
            signal = self._analyze_predictions(
                symbol=symbol,
                current_price=current_price,
                short_term_preds=short_term_preds,
                long_term_preds=long_term_preds,
                uncertainties=uncertainties,
                portfolio_context=portfolio_context,
                timestamp=current_time
            )
            
            self.logger.info(f"Generated signal for {symbol}: {signal.action} (confidence: {signal.confidence:.3f})")
            return signal
            
        except Exception as e:
            self.logger.error(f"Error generating signal for {symbol}: {e}")
            return self._create_hold_signal(current_time, f"Error: {str(e)}")
    
    def _analyze_predictions(self, symbol: str, current_price: float,
                           short_term_preds: List[float], long_term_preds: List[float],
                           uncertainties: Dict[str, List[float]], portfolio_context: Dict,
                           timestamp: datetime) -> TradingSignal:
        """
        Analyze predictions and generate trading signal.
        
        Args:
            symbol: Trading symbol
            current_price: Current asset price
            short_term_preds: Short-term predictions (1-6h)
            long_term_preds: Long-term predictions (1-6d)
            uncertainties: Uncertainty estimates for predictions
            portfolio_context: Portfolio information
            timestamp: Signal timestamp
            
        Returns:
            TradingSignal with recommended action
        """
        # Calculate short-term trend (average of first 3 predictions)
        short_term_avg = sum(short_term_preds[:3]) / min(3, len(short_term_preds))
        short_term_trend = (short_term_avg - current_price) / current_price
        
        # Calculate long-term trend (average of first 3 predictions)
        long_term_avg = sum(long_term_preds[:3]) / min(3, len(long_term_preds))
        long_term_trend = (long_term_avg - current_price) / current_price
        
        # Calculate weighted trend signal
        trend_signal = (self.short_term_weight * short_term_trend + 
                       self.long_term_weight * long_term_trend)
        
        # Calculate prediction uncertainty
        short_uncertainty = sum(uncertainties.get('short_term', [0, 0, 0])[:3]) / 3
        long_uncertainty = sum(uncertainties.get('long_term', [0, 0, 0])[:3]) / 3
        avg_uncertainty = (short_uncertainty + long_uncertainty) / 2
        
        # Calculate confidence based on trend strength and uncertainty
        trend_strength = abs(trend_signal)
        uncertainty_factor = max(0, 1 - (avg_uncertainty / self.uncertainty_threshold))
        base_confidence = min(trend_strength * 10, 1.0)  # Scale trend to confidence
        confidence = base_confidence * uncertainty_factor
        
        # Check trend alignment if required
        trends_aligned = (short_term_trend > 0) == (long_term_trend > 0) if self.trend_alignment_required else True
        
        # Determine action based on trend and confidence
        if not trends_aligned:
            action = "hold"
            reasoning = "Short-term and long-term trends not aligned"
        elif confidence < self.confidence_threshold:
            action = "hold"
            reasoning = f"Confidence {confidence:.3f} below threshold {self.confidence_threshold}"
        elif avg_uncertainty > self.uncertainty_threshold:
            action = "hold"
            reasoning = f"Uncertainty {avg_uncertainty:.3f} above threshold {self.uncertainty_threshold}"
        elif trend_signal > 0.001:  # 0.1% minimum movement
            action = "buy"
            reasoning = f"Positive trend signal {trend_signal:.4f} with confidence {confidence:.3f}"
        elif trend_signal < -0.001:  # 0.1% minimum movement
            action = "sell"
            reasoning = f"Negative trend signal {trend_signal:.4f} with confidence {confidence:.3f}"
        else:
            action = "hold"
            reasoning = f"Trend signal {trend_signal:.4f} too weak"
        
        # Calculate position size based on confidence
        position_size = self.position_size_base * confidence if action != "hold" else 0.0
        
        # Adjust for portfolio context
        current_positions = portfolio_context.get('positions', {})
        current_position = current_positions.get(symbol, 0)
        
        # Risk management: don't over-leverage
        max_position = portfolio_context.get('max_position_size', 0.1)
        if abs(current_position + position_size) > max_position:
            if action != "hold":
                position_size = max_position - abs(current_position)
                position_size = max(0, position_size)
                if position_size == 0:
                    action = "hold"
                    reasoning += " (position size limit reached)"
        
        return TradingSignal(
            action=action,
            confidence=confidence,
            quantity=position_size,
            reasoning=reasoning,
            timestamp=timestamp,
            short_term_predictions=short_term_preds,
            long_term_predictions=long_term_preds,
            uncertainties=uncertainties
        )
    
    def _create_hold_signal(self, timestamp: datetime, reasoning: str) -> TradingSignal:
        """Create a hold signal with given reasoning."""
        return TradingSignal(
            action="hold",
            confidence=0.0,
            quantity=0.0,
            reasoning=reasoning,
            timestamp=timestamp,
            short_term_predictions=[],
            long_term_predictions=[],
            uncertainties={}
        )
    
    async def backtest_signal(self, symbol: str, datetime_str: str, 
                            historical_data: List[Dict]) -> TradingSignal:
        """
        Generate a signal for backtesting at a specific historical time.
        
        This method is useful for strategy evaluation using historical data.
        """
        try:
            # Parse the datetime
            target_time = datetime.fromisoformat(datetime_str.replace('Z', '+00:00'))
            
            # Find the current price from historical data
            current_price = None
            for data_point in historical_data:
                data_time = datetime.fromisoformat(data_point['timestamp'].replace('Z', '+00:00'))
                if abs((data_time - target_time).total_seconds()) < 3600:  # Within 1 hour
                    current_price = data_point['close']
                    break
            
            if current_price is None:
                return self._create_hold_signal(target_time, "No price data for target time")
            
            # Get predictions for the historical time
            predictions = await self.prediction_client.get_predictions(
                symbol=symbol,
                datetime_str=datetime_str,
                prediction_types=['short_term', 'long_term']
            )
            
            if predictions['status'] != 'success':
                return self._create_hold_signal(target_time, "Historical prediction failed")
            
            # Create a mock portfolio context for backtesting
            portfolio_context = {
                'positions': {},
                'max_position_size': 0.1,
                'available_capital': 10000
            }
            
            # Analyze predictions
            signal = self._analyze_predictions(
                symbol=symbol,
                current_price=current_price,
                short_term_preds=predictions['predictions'].get('short_term', []),
                long_term_preds=predictions['predictions'].get('long_term', []),
                uncertainties=predictions['uncertainties'],
                portfolio_context=portfolio_context,
                timestamp=target_time
            )
            
            return signal
            
        except Exception as e:
            self.logger.error(f"Error in backtest signal for {symbol} at {datetime_str}: {e}")
            return self._create_hold_signal(datetime.now(), f"Backtest error: {str(e)}")
    
    def get_strategy_parameters(self) -> Dict[str, Any]:
        """Get current strategy parameters."""
        return {
            'short_term_weight': self.short_term_weight,
            'long_term_weight': self.long_term_weight,
            'confidence_threshold': self.confidence_threshold,
            'uncertainty_threshold': self.uncertainty_threshold,
            'position_size_base': self.position_size_base,
            'trend_alignment_required': self.trend_alignment_required
        }
    
    def update_parameters(self, new_params: Dict[str, Any]):
        """Update strategy parameters."""
        for param, value in new_params.items():
            if hasattr(self, param):
                setattr(self, param, value)
                self.logger.info(f"Updated {param} to {value}")
        
    def get_debug_info(self) -> Dict[str, Any]:
        """Get debug information about the strategy."""
        model_info = self.prediction_client.get_model_info() if self.prediction_client else {}
        
        return {
            'strategy_name': self.name,
            'version': self.version,
            'parameters': self.get_strategy_parameters(),
            'prediction_client': model_info,
            'last_signal_time': getattr(self, 'last_signal_time', None)
        }
